#!/usr/bin/python
import xcffib
# Returns the atom for any atom name.
def get_atom(conn, name):
    return conn.core.InternAtom(False, len(name), name).reply().atom
# Calling conn.get_atom(...) is the same as get_atom(conn ...). It's just more python-y this way
xcffib.Connection.get_atom = get_atom

import xcffib.xproto
CW = xcffib.xproto.CW
EventMask = xcffib.xproto.EventMask
WindowClass = xcffib.xproto.WindowClass

import window
Window = window.Window

conn = xcffib.Connection() # The connection to the X11 server
window.conn = conn # Set the connection for the window module
screen = conn.get_screen_pointers()[0] # The first screen from the server. SCREEN AND MONITOR ARE NOT THE SAME TERMS!
name = "tueswm" # The name of the window manager


root = Window(screen.root) # The root window
windows = {}

# from https://rosettacode.org/wiki/Window_creation/X11#Python
def create_window(x, y, w, h):
    wid = conn.generate_id()
    conn.core.CreateWindow(
            screen.root_depth,
            wid,
            root.wid,
            x,
            y,
            w,
            h,
            0,
            WindowClass.InputOutput,
            screen.root_visual,
            CW.BackPixel | CW.EventMask,
            [screen.white_pixel, EventMask.StructureNotify | EventMask.Exposure]
            )
    return Window(wid)

def run():
    while True:
        event = conn.wait_for_event()
        if False: pass # So you can comment and move stuff around 
        elif isinstance(event, xcffib.xproto.ConfigureRequestEvent): configure_request_event(event)
        elif isinstance(event, xcffib.xproto.MapRequestEvent): map_request_event(event)
        elif isinstance(event, xcffib.xproto.DestroyNotifyEvent): destroy_notify_event(event)
        else: print(type(event))
        conn.flush()

def configure_request_event(event):
    Window(event.window).configure(event.x, event.y, event.width, event.height, event.border_width, event.sibling, event.stack_mode, event.value_mask)

def map_request_event(event):
    windows[event.window] = Window(event.window)
    if windows[event.window].get_attributes().override_redirect: return
    conn.core.MapWindow(event.window)
    
def destroy_notify_event(event):
    del windows[event.window]

# Checks if another wm is already running
def check_other_wm():
    supporting_wid = root.get_property("_NET_SUPPORTING_WM_CHECK", "WINDOW").to_atoms()
    if len(supporting_wid) > 0:
        supporting_wid = supporting_wid[0]
        supporting_win = Window(conn, supporting_wid)
        existing_wmname = supporting_win.get_property("_NET_WM_NAME", "UTF8_STRING").to_string()
        if existing_wmname:
            raise Exception("Another window manager ({}) is running.".format(existing_wmname))

def make_supporting_window_for_wm_check():
    supporting_win = create_window(-1, -1, 1, 1)
    supporting_win.set_property("_NET_SUPPORTING_WM_CHECK", "WINDOW",      [supporting_win.wid])
    supporting_win.set_property("_NET_WM_NAME",             "UTF8_STRING", name)
    root.set_property(     "_NET_SUPPORTING_WM_CHECK", "WINDOW",      [supporting_win.wid])

# Sets the supported atoms from the ewmh extension
# https://en.wikipedia.org/wiki/Extended_Window_Manager_Hints
# The plan is to support all of them
def set_supported_atoms():
    root.set_property("_NET_SUPPORTED", "ATOM", [conn.get_atom(prop) for prop in [
        "_NET_SUPPORTED",
        "_NET_SUPPORTING_WM_CHECK",
        "_NET_WM_NAME",
        ]])

# Selects the events we want to listen to
# All the possible events are listed but I commented the ones I dont want to respond to
def select_events():
    root.set_attributes(CW.EventMask, [
        #EventMask.NoEvent |
        #EventMask.KeyPress |
        #EventMask.KeyRelease |
        EventMask.ButtonPress |
        EventMask.ButtonRelease |
        EventMask.EnterWindow |
        EventMask.LeaveWindow |
        #EventMask.PointerMotion |
        #EventMask.PointerMotionHint |
        #EventMask.Button1Motion |
        #EventMask.Button2Motion |
        #EventMask.Button3Motion |
        #EventMask.Button4Motion |
        #EventMask.Button5Motion |
        #EventMask.ButtonMotion |
        #EventMask.KeymapState |
        EventMask.Exposure |
        EventMask.VisibilityChange |
        EventMask.StructureNotify |
        EventMask.ResizeRedirect |
        #EventMask.SubstructureNotify |
        EventMask.SubstructureRedirect |
        #EventMask.FocusChange |
        #EventMask.PropertyChange |
        #EventMask.ColorMapChange |
        #EventMask.OwnerGrabButton |
        0 # Zero at the end so you can comment and uncomment without worrying about the pipes
    ])

# TODO
def  set_default_cursor():
    pass

def init():
    check_other_wm()
    make_supporting_window_for_wm_check()
    set_supported_atoms()
    select_events()
    set_default_cursor()
    conn.flush()

init()
run()
