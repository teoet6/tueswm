#!/usr/bin/python
import os
import time
import xcffib
import xcffib.xproto

WindowClass = xcffib.xproto.WindowClass
CW = xcffib.xproto.CW
EventMask = xcffib.xproto.EventMask

conn = xcffib.Connection() # The connection to the X11 server
screen = conn.get_screen_pointers()[0] # The first screen from the server. SCREEN AND MONITOR ARE NOT THE SAME TERMS!
root = Window(conn, screen.root) # The root window
name = "tueswm" # The name of the window manager

# Returns the atom for any atom name.
def get_atom(conn, name):
    return conn.core.InternAtom(False, len(name), name).reply().atom

# Calling conn.get_atom(...) is the same as get_atom(conn ...). It's just more python-y this way
xcffib.Connection.get_atom = get_atom

class Window():
    def __init__(self, wid):
        conn = conn # Connection with X server
        self.wid = wid # Window id of the window
        
    def get_property(self, prop, type):
        return conn.core.GetProperty(
                False, 
                self.wid, 
                conn.get_atom(prop),
                conn.get_atom(type),
                0, 
                (2 ** 32) - 1
                ).reply().value

    def set_property(self, prop, type, value):
        if isinstance(value, str): 
            value = value.encode() # encode the string as utf8
            format = 8
        elif isinstance(value, list): 
            format = 32
        else:
            raise TypeError("value should be either a list of atoms or a string!")

        conn.core.ChangeProperty(
                xcffib.xproto.PropMode.Replace,
                self.wid,
                conn.get_atom(prop),
                conn.get_atom(type),
                format,
                len(value),
                value
                )

    def set_attributes(self, value_mask, value_list):
        conn.core.ChangeWindowAttributes(self.wid, value_mask, value_list)

# from https://rosettacode.org/wiki/Window_creation/X11#Python
def create_window(x, y, w, h):
    wid = conn.generate_id()
    conn.core.CreateWindow(
            screen.root_depth,
            wid,
            root.wid,
            x,
            y,
            w,
            h,
            0,
            WindowClass.InputOutput,
            screen.root_visual,
            CW.BackPixel | CW.EventMask,
            [screen.white_pixel, EventMask.StructureNotify | EventMask.Exposure]
            )
    return Window(conn, wid)

def run():
    conn.flush()
    while True:
        event = conn.wait_for_event()
        if (isinstance(event, xcffib.xproto.MapRequestEvent)): map_request_event(event)
        if (isinstance(event, xcffib.xproto.MotionNotifyEvent)): motion_notify_event(event)
        if (isinstance(event, xcffib.xproto.KeyReleaseEvent)): key_release_event(event)
        else: print(type(event))

# Checks if another wm is already running
def check_other_wm():
    supporting_wid = root.get_property("_NET_SUPPORTING_WM_CHECK", "WINDOW").to_atoms()
    if len(supporting_wid) > 0:
        supporting_wid = supporting_wid[0]
        supporting_win = Window(conn, supporting_wid)
        existing_wmname = supporting_win.get_property("_NET_WM_NAME", "UTF8_STRING").to_string()
        if existing_wmname:
            raise Exception("Another window manager ({}) is running.".format(existing_wmname))

def make_supporting_window_for_wm_check():
    supporting_win = create_window(-1, -1, 1, 1)
    supporting_win.set_property("_NET_SUPPORTING_WM_CHECK", "WINDOW",      [supporting_win.wid])
    supporting_win.set_property("_NET_WM_NAME",             "UTF8_STRING", name)
    root.set_property(     "_NET_SUPPORTING_WM_CHECK", "WINDOW",      [supporting_win.wid])

# Sets the supported atoms from the ewmh extension
# https://en.wikipedia.org/wiki/Extended_Window_Manager_Hints
# The plan is to support all of them
def set_supported_atoms():
    root.set_property("_NET_SUPPORTED", "ATOM", [conn.get_atom(prop) for prop in [
        "_NET_SUPPORTED",
        "_NET_SUPPORTING_WM_CHECK",
        "_NET_WM_NAME",
        ]])

# Selects the events we want to listen to
def select_events():
    root.set_attributes(CW.EventMask, [
        EventMask.KeyPress |
        EventMask.KeyRelease |
        EventMask.ButtonPress |
        EventMask.ButtonRelease |
        EventMask.EnterWindow |
        EventMask.LeaveWindow |
        EventMask.PointerMotion |
        EventMask.KeymapState |
        EventMask.Exposure |
        EventMask.StructureNotify |
        EventMask.ResizeRedirect |
        EventMask.SubstructureNotify |
        EventMask.SubstructureRedirect |
        EventMask.FocusChange |
        EventMask.PropertyChange])

# TODO
def  set_default_cursor():
    pass

# This function gets called when a window wants to get mapped i.e. when a window wants to be displayed
def map_request_event(event):
    print(dir(event))

# This function gets called when the mouse pointer is moved
def motion_notify_event(event):
    pass

# This funcron gets called when a key on the keyboard is released
def key_release_event(event):
    print(conn.code_to_syms(event.detail));
    print(event.state);

check_other_wm()
make_supporting_window_for_wm_check()
set_supported_atoms()
select_events()
set_default_cursor()
run()
